# BrashLens Project Rules for Cursor AI
работай только в виртуальном окружении, не запускай пайтон скрипты без виртуального окружения.
если виртулаьное окружение нет или не установлены зависимоти - пиши мне в чат, 
при отладке и запуске этого проекта используй только виртальное окружение а не глобальные настройки скриптов.

## Секретные данные и конфигурация

**Файл .secret:**
- Справочник всех чувствительных данных проекта (пароли, токены, API ключи)
- Расположен в корне проекта: `.secret`
- НЕ коммитится в Git (добавлен в .gitignore)
- Используется как справочник для заполнения .env файлов
- Содержит актуальные учетные данные для БД, API ключи и другие секреты
- При работе с проектом используй данные из .secret для настройки окружения

**База данных:**
- Имя БД: `brashlens_db`
- Пользователь: `govardvolov`
- Пароль: хранится в `.secret`
- Инициализация: используй `infrastructure/init_db.sh` для создания/обновления БД и пользователя


## Project Context
You are working on BrashLens - a Telegram Mini App for photographer business management.
Tech stack: FastAPI, PostgreSQL, Redis, Celery, React, TypeScript, Docker.

## Core Principles

### Code Quality
- Follow industry best practices and modern standards
- Write clean, maintainable, self-documenting code
- Use type hints (Python) and TypeScript strict mode
- Keep functions small and focused (single responsibility)
- DRY principle - don't repeat yourself

### Architecture
- RESTful API design patterns
- Repository pattern for data access
- Service layer for business logic
- Dependency injection where applicable
- Separation of concerns (models, services, API, UI)

### Python/FastAPI Standards
- Use Pydantic v2 for validation and schemas
- SQLAlchemy 2.0 async style
- Follow PEP 8 with Black formatter
- Type hints everywhere
- Async/await for IO operations
- Context managers for resources

### React/TypeScript Standards
- Functional components with hooks
- Custom hooks for reusable logic
- React Query for server state
- Zustand for client state
- Proper error boundaries
- Code splitting and lazy loading

### Database
- Always use migrations (Alembic)
- Index foreign keys and frequently queried fields
- Use transactions for multi-step operations
- Implement soft deletes where appropriate
- UTC timestamps everywhere

### Security
- Never commit secrets/keys
- Use environment variables
- Validate all inputs (Pydantic schemas)
- Sanitize user data
- HTTPS only in production
- **CORS properly configured** - настраивается через `ALLOWED_ORIGINS` в config
- **Rate limiting** для защиты от злоупотреблений (slowapi)
- Global exception handlers для безопасной обработки ошибок

### Testing
- Unit tests for business logic
- Integration tests for API endpoints
- Test error cases and edge conditions
- Mock external dependencies

### Performance
- Lazy load images
- Paginate large datasets
- Use database indexes
- Cache frequently accessed data (Redis)
- Optimize queries (avoid N+1)
- Background tasks for heavy operations (Celery)

### Comments & Documentation
- Write brief, essential comments only
- Document complex logic and "why", not "what"
- Keep commit messages concise and clear
- Update API docs when endpoints change

### Error Handling
- Use proper HTTP status codes
- Provide clear error messages
- **Global exception handlers** в `app/core/exceptions.py`
- **Centralized logging** через `app/core/logging.py`
- Log errors with context
- Graceful degradation
- User-friendly error messages in UI

### Git Workflow
- **Работаем в ветке `dev`** - основная ветка разработки
- Commit after each logical change
- Clear, concise commit messages using conventional commits (`feat:`, `fix:`, `docs:`, `refactor:`)
- **По окончанию этапа:**
  1. Коммитим изменения в `dev` с описанием что изменилось
  2. Пушим `dev` в удаленный репозиторий
  3. Мержим `dev` в `main`
  4. Пушим `main` в удаленный репозиторий
  5. Возвращаемся в ветку `dev`
- Keep commits atomic and focused
- **Кратко:** "Запушить dev, смержить в main, вернуться в dev"

## Specific Rules

### File Structure
```
backend/
  app/
    models/       # SQLAlchemy models
    schemas/      # Pydantic schemas (requests.py, responses.py)
    services/     # Business logic
    api/          # FastAPI routes
      v1/         # API version 1 routes
        health.py # Health check endpoints
        test.py   # Test endpoints
        cache.py  # Redis cache endpoints
        tasks.py  # Celery tasks endpoints
    core/         # Config, dependencies, logging, exceptions, limiter
    utils/        # Helpers
    bot/          # Telegram bot handlers

frontend/
  src/
    components/   # React components
    pages/        # Page components
    hooks/        # Custom hooks
    services/     # API client
    store/        # State management
    utils/        # Helpers
    types/        # TypeScript types
```

### Naming Conventions
- Python: snake_case for functions/variables, PascalCase for classes
- TypeScript: camelCase for functions/variables, PascalCase for components/types
- Files: lowercase with hyphens (kebab-case)
- Constants: UPPER_SNAKE_CASE
- Database: plural table names (users, bookings)

### API Design
- Use proper HTTP methods (GET, POST, PATCH, DELETE)
- **Versioned URLs: `/api/v1/...`** - все endpoints должны быть под версией
- API routes разделены по функциональности в `app/api/v1/`:
  - `health.py` - health checks
  - `test.py` - тестовые endpoints
  - `cache.py` - Redis cache endpoints
  - `tasks.py` - Celery tasks endpoints
- Use Pydantic schemas for request/response validation (`app/schemas/`)
- Use query params for filtering/sorting
- Consistent response format with typed schemas
- **Rate limiting** включен по умолчанию (60 req/min, настраивается через `RATE_LIMIT_PER_MINUTE`)
- **CORS** настраивается через `ALLOWED_ORIGINS` в config (по умолчанию `["*"]` для dev)

### Docker & Infrastructure

**Структура докеризации:**
Проект использует раздельную структуру с общей инфраструктурой:

```
BrashLens/
├── infrastructure/          # Общая инфраструктура (PostgreSQL, Redis)
│   ├── docker-compose.yml  # Отдельный compose для БД сервисов
│   └── .env.example
├── BrashLens/              # Основное приложение
│   ├── backend/            # FastAPI приложение
│   ├── frontend/           # React приложение
│   ├── docker-compose.yml  # Compose для приложения
│   └── .env.example
```

**Docker Network:**
- Все контейнеры в единой сети `shared-network`
- Инфраструктура создаёт сеть: `docker network create shared-network`
- Приложения подключаются к существующей сети: `external: true`

**Backend Services:**
- `backend` (fastapi) - основной API сервер (порт 8000 внутри, 8001 наружу для dev)
- `chat-bot` - отдельный Telegram бот сервис (python-telegram-bot)
- `celery-worker` - обработка фоновых задач
- `celery-beat` - планировщик периодических задач

**Data Layer (общие ресурсы в infrastructure/):**
- `brashlens_postgres` - основная БД + pgvector (порт 5432)
- `brashlens_redis` - кеш, очереди Celery, сессии (порт 6379)
- Запускаются из `infrastructure/docker-compose.yml`
- Используются всеми приложениями проекта через сеть `shared-network`

**Frontend:**
- `nginx` - статика Mini App + reverse proxy для API (будет добавлен)

**Volumes:**
- `postgres_data` - данные PostgreSQL
- `redis_data` - данные Redis
- `uploads` - загруженные файлы (будет добавлен)
- `static` - статические файлы (будет добавлен)

**Health Checks:**
- Обязательны для всех сервисов
- PostgreSQL: `pg_isready`
- Redis: `redis-cli ping`
- Backend: HTTP GET `/health`

**Порты:**
- Наружу: только nginx (80, 443) в production
- Между контейнерами: postgres:5432, redis:6379, fastapi:8000
- В dev: backend доступен на 8001 для разработки

**Масштабирование:**
- Celery workers можно множить: `--scale celery-worker=3`
- FastAPI можно множить через nginx upstream
- Redis и Postgres - single instance (мастер-реплика позже)

**Docker Best Practices:**
- Multi-stage builds for optimization
- Non-root users in containers
- .dockerignore to exclude unnecessary files
- Health checks for all services
- Restart policies: `unless-stopped` для dev, `always` для prod

### Remote Server & Deployment

**Режим работы на удаленном сервере (SSH/терминал сервера):**

При работе с удаленным сервером следуй этим правилам:

1. **Один шаг = 1-3 команды для выполнения НА СЕРВЕРЕ**
   - После каждого шага жди результат перед следующим
   - Если команды можно выполнить подряд - пиши их подряд
   - Если одна команда меняет дальнейший путь - только одна команда
   - Для сбора информации можно 3-5 команд подряд, лучше 3

2. **Формат команд:**
   - Команды пиши кратко, без комментариев в коде
   - Формат: краткое описание что делаем, затем команды для выполнения НА СЕРВЕРЕ
   - Всегда уточняй что команды выполняются на сервере, не локально

3. **Изменения файлов:**
   - Не создавай файлы и не меняй проект без явного разрешения
   - На сервере можно создавать `.env` файлы и обновлять конфигурацию для деплоя

4. **Пример хорошего формата:**
   ```
   проверяем докер контейнеры на сервере

   docker ps -a
   docker network ls
   ```

5. **Пример плохого формата:**
   ```
   # Проверка запущенных контейнеров
   docker ps -a
   # Проверка Docker сетей  
   docker network ls
   ```

**Деплой на сервер:**
- Используй существующую инфраструктуру (`shared_postgres`, `shared_redis`)
- Создавай отдельную БД для проекта (`brashlens_db`, пользователь `govardvolov`)
- Обновляй `docker-compose.yml` для подключения к существующим контейнерам
- Используй продакшн токен бота на сервере, dev токен локально
- Порты: backend на 8044 (или другой свободный порт)
- Создавай `.env` файлы на сервере с данными из `.secret`

**Настройка nginx:**
- Создавай конфиг в `/etc/nginx/sites-available/`
- Символическая ссылка в `/etc/nginx/sites-enabled/`
- SSL через Certbot (Let's Encrypt)
- Проксирование на backend контейнер через порт хоста

### Environment Variables
- Never hardcode config
- Use `.env.example` as template
- Use `.secret` file as reference for sensitive data (passwords, tokens, API keys)
- Validate required env vars on startup
- Different configs for dev/prod
- **ВАЖНО:** Файл `.secret` содержит все чувствительные данные проекта - используй его как справочник

## When Generating Code

1. **Ask clarifying questions** if requirements are unclear
2. **Suggest better approaches** if you see issues
3. **Follow existing patterns** in the codebase
4. **Be concise** - no unnecessary boilerplate
5. **Think before coding** - plan the approach
6. **Consider edge cases** and error scenarios
7. **Optimize for readability** over cleverness
8. **Write testable code** with clear interfaces

## Response Style
- Be brief and to the point
- Code first, explanations second
- Highlight important decisions
- Suggest improvements when relevant
- No excessive pleasantries

## Iteration Workflow
Each iteration ends with deployment:
1. Write code following best practices
2. Add necessary tests
3. Update migrations if needed
4. Test locally with Docker Compose
5. Prepare for deployment
6. Document changes briefly
